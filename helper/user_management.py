from datetime import datetime, timedeltaimport gcimport hmacimport mathimport subprocess as spimport psutilimport streamlit as stfrom streamlit_server_state import server_state, server_state_lock, no_rerunimport torchdef check_password():    """Check if a user entered the password correctly"""    if not(st.session_state["available"]):        # people currently using it        current_users = sorted([k for k, v in server_state["locked"].items() if v])        current_emails = [st.session_state["users_list"].loc[lambda x: x.user == user, "email"].values[0] for user in current_users]                error_string = "Application in use by:\n\n"                for i in range(len(current_users)):            error_string += f"""[{current_users[i]}](mailto:{current_emails[i]}) (reserved for {server_state["last_used_threshold"][current_users[i]]} minutes)\n\n"""                error_string += f"""Refresh in {min(server_state["last_used_threshold"].values())} minutes, if someone has stopped using it you will be able to log in."""        st.error(error_string)    def password_entered():        """Checks whether a password entered by the user is correct."""        st.session_state["override"] = False        if hmac.compare_digest(st.session_state["password"], st.secrets["password"]):            st.session_state["password_correct"] = True            del st.session_state["password"]        # override password        elif hmac.compare_digest(st.session_state["password"], st.secrets["override"]):            st.session_state["password_correct"] = True            st.session_state["override"] = True            del st.session_state["password"]        else:            st.session_state["password_correct"] = False    # Return True if the password is validated.    if st.session_state.get("password_correct", False):        if st.session_state["available"]:            return True        # show input for user name    st.session_state["user_name"] = st.selectbox(       "User",       st.session_state["users_list"],       index=None,       placeholder="Select user...",    )    # Show input for password.    st.text_input(        "Password", type="password", on_change=password_entered, key="password"    )    if "password_correct" in st.session_state:        st.error("Password incorrect")    return Falsedef update_server_state(key, value):    "update the server state variable"    with no_rerun:        with server_state_lock[key]:            server_state[key] = value                        def record_use(future_lock=False, free_up=False):    "record a usage, future lock to put it in the future for long running processes"    with no_rerun:        with server_state_lock["last_used"]:            if future_lock:                server_state["last_used"][st.session_state["user_name"]] = datetime.now() + timedelta(hours=2, minutes=0)            elif free_up:                server_state["last_used"][st.session_state["user_name"]] = datetime.now() - timedelta(hours=6, minutes=0)            else:                server_state["last_used"][st.session_state["user_name"]] = datetime.now()                                def clear_models():    if f'model_{st.session_state["db_name"]}' in server_state:        try:            server_state[f'model_{st.session_state["db_name"]}'].close_connection()        except:            pass        del server_state[f'model_{st.session_state["db_name"]}'].llm        del server_state[f'model_{st.session_state["db_name"]}']        gc.collect()def calc_cuda(n_users):    "how many users can the GPU support"        command = "nvidia-smi --query-gpu=memory.free --format=csv"    memory_free_info = sp.check_output(command.split()).decode('ascii').split('\n')[:-1][1:]    memory_free_value = [int(x.split()[0]) for i, x in enumerate(memory_free_info)][0]        command = "nvidia-smi --query-gpu=memory.total --format=csv"    memory_total_info = sp.check_output(command.split()).decode('ascii').split('\n')[:-1][1:]    memory_total_value = [int(x.split()[0]) for i, x in enumerate(memory_total_info)][0]                              memory_used_value = memory_total_value - memory_free_value        return math.floor(memory_total_value / (memory_used_value / n_users))def calc_mps(n_users):    "how many users can the MPS backend support"        return math.floor(psutil.virtual_memory()[0] * 1.15 / (torch.mps.driver_allocated_memory() / n_users))def calc_max_users(n_users):    "given current existing user(s), how many can the machine support"        if torch.cuda.is_available():        device = "cuda"    elif torch.backends.mps.is_available() and torch.backends.mps.is_built():        device = "mps"    else:        device = "cpu"        if device == "cpu":        max_users = 1    elif device == "mps":        max_users = calc_mps(n_users)    elif device == "cuda":        max_users =  calc_cuda(n_users)        return max_users